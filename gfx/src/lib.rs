pub mod errors;
mod funcs;
pub mod types;

pub use funcs::*;

/// Converts a Rust-native expression into a [GL-type][gl::types] with a `try_into`.
///
/// Because the GL-types are all type aliases generated by the system's OpenGL implementation (`bindings.rs` in the
/// [`gl`] crate), these will usually be no-ops; that is, `isize` into `GLsizeiptr` will basically always become `isize`
/// into `isize`.
///
/// # Syntax
///
/// Pass three comma separated arguments to this macro:
///
/// 1.  The expression to convert;
/// 2.  The type to `try_into` it into; and
/// 3.  What error message to `.expect` with.
///
/// ```
/// let num_buffers = gl_convert!(n, GLsizei, "buffer creation count");
/// ```
///
/// The third parameter is normally given simply as a name for the type, at which point the error message will be,
/// `"[name] should fit into a '[type]'"` (e.g., `"buffer size should fit into a 'GLsizeiptr'"`). A unique message can
/// be provided by prefixing the third parameter with `msg:`:
///
/// ```
/// let size = gl_convert!(buffer.len(), GLsizeiptr, msg: "your buffer is too large!!");
/// ```
macro_rules! gl_convert {
    ($src:expr, $into:ty, $src_name:expr$(,)?) => {
        $crate::gl_convert!(
            $src,
            $into,
            msg: concat!($src_name, " should fit into a `", stringify!($into), "`"),
        )
    };
    ($src:expr, $into:ty, msg: $err_msg:expr$(,)?) => {
        // Inner scope so that we can declare a variable with an annotation for `try_into`
        {
            let x: $into = ($src).try_into().expect($err_msg);
            x
        }
    };
}

pub(crate) use gl_convert;
