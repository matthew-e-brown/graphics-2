//! Macros for generating matrices and vectors.
//!
//! This crate is used to implement the `gloog-math` crate. The inner workings of this it are an implementation detail;
//! this documentation is provided on the off-chance that anybody else wants to use these macros to generate simple
//! matrix or vector structs, but it may not always stay 100% up to date as this library is updated to support
//! `gloog-math`.
//!
//!
//! # Generated Functionality
//!
//! The structs generated by the creation macros in this crate have some common functionality out of the box. Because
//! vectors and matrices could contain any type, however, not every operation can be defined automatically. For example,
//! a vector holding three vectors (`BVec3`), could not have a dot or cross product defined for it. Additional
//! functionality for those sorts of operations (dot and cross product, matrix multiplication and identities, etc.) are
//! provided by the other macros exported from this crate.
//!
//!
//! ## Built-in functionality
//!
//! All of the vectors and matrices created by the macros in this crate have the following.
//!
//! - `new` constructors that accept arguments in **row-major order**, to match mathematical notation.
//! - Operator overloads for [`Index`] and [`IndexMut`]:
//!   - Vectors are indexed with [`usize`].
//!   - Matrices are indexed using tuples of <code>([usize], [usize])</code>, where the first number is the row and the
//!   - second is the
//!     column (again, to match mathematical notation).
//!   - [An extra macro][matrix_cols_as_vector] is provided to generate by-column indexes of matrices, allowing
//!     `matrix[col][row]` indexing.
//! - Conversions with [`From`], [`Into`], [`AsRef`], [`AsMut`], [`Borrow`], and [`BorrowMut`] for each struct's
//!   "wrapped type" (e.g. `[f32; 3]` for a `Vec3`).
//! - All generated structs are `repr(transparent)`.
//!
//! Matrices also get `from_cols` and `from_rows` methods, which are generic over any type that implements [`Into`] for
//! the wrapped type (e.g. passing four `Into<[f32; 4]>` for `Mat4::from_cols`). `try_from_cols` and `try_from_rows` are
//! also provided for types that implement [`TryFrom`][core::convert::TryFrom] instead.
//!
//! All generated methods have documentation comments automatically generated as well.
//!
//!
//! [`Index`]:      core::ops::Index
//! [`IndexMut`]:   core::ops::IndexMut
//! [`From`]:       core::convert::From
//! [`Into`]:       core::convert::Into
//! [`AsRef`]:      core::convert::AsRef
//! [`AsMut`]:      core::convert::AsMut
//! [`Borrow`]:     core::borrow::Borrow
//! [`BorrowMut`]:  core::borrow::BorrowMut


// TODO: Re-implement this "suite" of macros as a small amount of highly-configurable derive/attribute macros. Or, at
// the very least, as one big procedural macro.
//
// Instead of having a bunch of different `Input` structs for different mini macros, we can just have one large input
// struct with a bunch of `Option`al things in it, allowing everything to run with a single macro invocation.


mod common;
mod matrix;
mod vector;


/// Replaces the boilerplate of wrapping the functions from the [`vector`] and [`matrix`] modules with `#[proc_macro]`
/// exports.
///
/// # Syntax
///
/// - The name to export the macro under, optionally proceeded by a doc-comment for the exported macro.
/// - The path to the function within [`vector`] or [`matrix`] to delegate this macro to.
/// - The path to the struct that said function takes as input.
macro_rules! export_macro {
    (
        $(#[doc=$doc:expr])*
        $export_name:ident,
        $actual_path:path,
        $input_name:path$(,)?
    ) => {
        $(#[doc=$doc])*
        #[proc_macro]
        pub fn $export_name(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
            let input = syn::parse_macro_input!(input as $input_name);
            let output = $actual_path(input);
            output.into()
        }
    };
}


export_macro! {
    /// Creates a vector struct.
    ///
    /// See [this crate's documentation](self) for more details.
    create_vector,
    vector::create_base,
    vector::CreationInput,
}

export_macro! {
    /// Implements operations between a vector and its inner type.
    ///
    /// Implements the operations for all owned and reference types, commutatively wherever possible.
    ///
    /// Implements multiplication and division through [`Div`] and [`Mul`] as well as [`DivAssign`] and [`MulAssign`].
    /// As such, it can only be done for vectors that contain types that implement those traits.
    ///
    /// [`Div`]: core::ops::Div
    /// [`Mul`]: core::ops::Mul
    /// [`DivAssign`]: core::ops::DivAssign
    /// [`MulAssign`]: core::ops::MulAssign
    vector_impl_scalar_ops,
    vector::impl_scalar_ops,
    vector::SimpleInput,
}

export_macro! {
    /// Implements component-wise operations between a vector and itself.
    ///
    /// Implements the operations for all owned and reference types, commutatively wherever possible.
    ///
    /// Implements addition and subtraction through [`Add`] and [`Sub`] as well as [`AddAssign`] and [`SubAssign`]. As
    /// such, it can only be done for vectors that contain types that implement those traits.
    ///
    /// [`Add`]: core::ops::Add
    /// [`Sub`]: core::ops::Sub
    /// [`AddAssign`]: core::ops::AddAssign
    /// [`SubAssign`]: core::ops::SubAssign
    vector_impl_self_ops,
    vector::impl_self_ops,
    vector::SimpleInput,
}

export_macro! {
    /// Implements the dot product operation between a vector and itself.
    ///
    /// Implementation is done using multiplication and addition. As such, it can only be done for vectors that contain
    /// types that implement [`Mul`] and [`Add`].
    ///
    /// [`Mul`]: core::ops::Mul
    /// [`Add`]: core::ops::Add
    vector_impl_dot_product,
    vector::impl_dot_product,
    vector::SimpleInput,
}


// ---------------------------------------------------------------------------------------------------------------------


export_macro! {
    /// Creates a matrix struct.
    ///
    /// See [this crate's documentation](self) for more details.
    create_matrix,
    matrix::create_base,
    matrix::CreationInput,
}


export_macro! {
    /// Implements operations between a matrix and its inner type.
    ///
    /// Implements the operations for all owned and reference types, commutatively wherever possible.
    ///
    /// Implements addition and subtraction through [`Add`] and [`Sub`] as well as [`AddAssign`] and [`SubAssign`]. As
    /// such, it can only be done for matrices that contain types that implement those traits.
    ///
    /// [`Add`]: core::ops::Add
    /// [`Sub`]: core::ops::Sub
    /// [`AddAssign`]: core::ops::AddAssign
    /// [`SubAssign`]: core::ops::SubAssign
    matrix_impl_scalar_ops,
    matrix::impl_scalar_ops,
    matrix::SimpleInput,
}

export_macro! {
    /// Implements component-wise operations between a matrix and itself.
    ///
    /// Implements the operations for all owned and reference types, commutatively wherever possible.
    ///
    /// Implements addition and subtraction through [`Add`] and [`Sub`] as well as [`AddAssign`] and [`SubAssign`]. As
    /// such, it can only be done for matrices that contain types that implement those traits.
    ///
    /// [`Add`]: core::ops::Add
    /// [`Sub`]: core::ops::Sub
    /// [`AddAssign`]: core::ops::AddAssign
    /// [`SubAssign`]: core::ops::SubAssign
    matrix_impl_self_ops,
    matrix::impl_self_ops,
    matrix::SimpleInput,
}


// ---------------------------------------------------------------------------------------------------------------------
// ---------------------------------------------------------------------------------------------------------------------


mod other {
    use proc_macro2::TokenStream;
    use quote::quote;
    use syn::parse::{Parse, ParseStream};
    use syn::{Token, Type, TypePath};

    pub(crate) struct MatToVecInput {
        pub matrix: TypePath,
        pub vector: Type,
    }

    impl Parse for MatToVecInput {
        fn parse(input: ParseStream) -> syn::Result<Self> {
            let matrix = input.parse()?;
            input.parse::<Token![->]>()?;
            let vector = input.parse()?;
            Ok(Self { matrix, vector })
        }
    }


    pub(crate) fn cols_as_vector(input: MatToVecInput) -> TokenStream {
        let MatToVecInput { matrix, vector } = input;
        quote! {
            impl ::core::ops::Index<usize> for #matrix {
                type Output = #vector;

                fn index(&self, index: usize) -> &Self::Output {
                    self.m.index(index).as_ref()
                }
            }

            impl ::core::ops::IndexMut<usize> for #matrix {
                fn index_mut(&mut self, index: usize) -> &mut Self::Output {
                    self.m.index_mut(index).as_mut()
                }
            }
        }
    }
}


export_macro! {
    matrix_cols_as_vector,
    other::cols_as_vector,
    other::MatToVecInput,
}
