//! Macros for generating matrices and vectors.
//!
//! The inner workings of this crate are an implementation detail. The only reason there are doc-comments here at all is
//! because I'm insane and like to do things "properly" even if nobody else will ever read it.
//!
//! See the [`math`](../math/index.html) crate for **end-user documentation**.
//!
//!
//! # Functionality
//!
//! The structs generated by the creation macros have some functionality built into them. However, because vectors and
//! matrices could contain any type, not every operation can be defined out of the box. For example, a `BVec3`, that
//! holds three booleans, cannot have a dot or cross product.
//!
//! Additional functionality for things that require more mathematical operations, like dot and cross products, matrix
//! multiplication, matrix identities, and so on, are provided by the other macros exported from this crate.
//!
//!
//! ## Built-in functionality
//!
//! All of the matrices and vectors created by the macros in this crate share some common features.
//!
//! - `new` constructors that accepts arguments in row-major order, to match mathematical order.
//! - Indexing operators for both [`Index`][std::ops::Index] and [`IndexMut`][std::ops::IndexMut]
//!   - For vectors, simply using [`usize`].
//!   - For matrices, using tuples of `(usize, usize)`, which follows mathematical convention for ordering (matrices are
//!     indexed row-first).
//! - Conversions between vectors and arrays of their held type, and between matrices and two-dimensional arrays of
//!   their held type. Since all vectors and matrices are simple wrappers, they are marked as **`repr(transparent)`**,
//!   making this conversion free.
//! - For matrices, conversions between N columns to the matrix, or M rows to the matrix, are provided.
//!
//!
//! # Macro invocation syntax
//!
//! The macros exported by this crate use one of two syntaxes. Creating a struct requires knowing a little bit more than
//! adding to a struct. Namely, we need to know of any additional attributes the struct needs to have and what
//! visibility it should have.
//!
//!
//! ## Creation macros
//!
//! The syntax for creating a struct is as follows:
//!
//! - The struct's declaration "header." This includes any attributes, visibility, and the name, written as though the
//!   struct was actually being declared.
//! - Separated by a semicolon, the type that the matrix or vector should contain. The only requirement is that the
//!   inner type implements [`Clone`].
//! - Separated by comma(s), the size of the matrix or vector as a [`usize`] literal.
//!
//! Because attributes are passed through with the macro invocation, derive macros should be included here. Aside from
//! [`Clone`], no derive attributes are added automatically. Documentation is generated for the struct itself
//! automatically.
//!
//!
//! ### Examples
//!
//! The following macro invocation:
//!
//! ```
//! # use math_proc::create_vector;
//! create_vector! {
//!     #[derive(Copy, Debug)]
//!     pub(crate) struct IVec5;
//!     i32, 5;
//! }
//! ```
//!
//! Will create the following:
//!
//! ```
//! #[derive(Copy, Clone, Debug)] // Clone is always added automatically
//! pub(crate) struct IVec5 {
//!     v: [i32; 5],
//! }
//! ```
//!
//! This invocation:
//!
//! ```
//! # use math_proc::create_matrix;
//! create_matrix! {
//!     #[derive(Copy, Debug)]
//!     pub struct DMat16x23;
//!     f64, 16, 23;
//! }
//! ```
//!
//! Will create:
//!
//! ```
//! #[derive(Copy, Clone, Debug)] // Clone is always added automatically
//! pub struct DMat16x23 {
//!     m: [[f64; 16]; 23],
//! }
//! ```
//!
//!
//! ## Simple input
//!
//! Adding to a vector or matrix requires only a few things:
//!
//! - The name of the struct;
//! - What type it contains;
//! - How large it is.
//!
//!
//! ### Examples
//!
//! To implement the dot product on a vector:
//!
//! ```
//! # use math_proc::vector_impl_dot_product;
//! vector_impl_dot_product!(Vec3, f32, 3);
//! ```
//!
//! To implement conversions on matrices:
//!
//! ```
//! # use math_proc::matrix_impl_row_col_conversions;
//! matrix_impl_row_col_conversions!(Mat3, f32, 3, 3);
//! ```

mod common;
mod matrix;
mod vector;


/// Replaces the boilerplate of wrapping the functions from the [`vector`] and [`matrix`] modules with `#[proc_macro]`
/// exports.
///
/// # Syntax
///
/// - The name to export the macro under, optionally proceeded by a doc-comment for the exported macro.
/// - The path to the function within [`vector`] or [`matrix`] to delegate this macro to.
/// - The path to the struct that said function takes as input.
macro_rules! export_macro {
    (
        $(#[doc=$doc:expr])*
        $export_name:ident,
        $actual_path:path,
        $input_name:path$(,)?
    ) => {
        $(#[doc=$doc])*
        #[proc_macro]
        pub fn $export_name(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
            let input = syn::parse_macro_input!(input as $input_name);
            let output = $actual_path(input);
            output.into()
        }
    };
}


export_macro! {
    /// Creates a vector struct.
    ///
    /// See [this crate's documentation](self) for more details.
    create_vector,
    vector::create_base,
    vector::CreationInput,
}

export_macro! {
    /// Implements operations between a vector and its inner type.
    ///
    /// Implements the operations for all owned and reference types, commutatively wherever possible.
    ///
    /// Implements multiplication and division through [`Div`] and [`Mul`] as well as [`DivAssign`] and [`MulAssign`].
    /// As such, it can only be done for vectors that contain types that implement those traits.
    vector_impl_scalar_ops,
    vector::impl_scalar_ops,
    vector::SimpleInput,
}

export_macro! {
    /// Implements component-wise operations between a vector and itself.
    ///
    /// Implements the operations for all owned and reference types, commutatively wherever possible.
    ///
    /// Implements addition and subtraction through [`Add`] and [`Sub`] as well as [`AddAssign`] and [`SubAssign`]. As
    /// such, it can only be done for vectors that contain types that implement those traits.
    vector_impl_self_ops,
    vector::impl_self_ops,
    vector::SimpleInput,
}

export_macro! {
    /// Implements the dot product operation between a vector and itself.
    ///
    /// Implementation is done using multiplication and addition. As such, it can only be done for vectors that contain
    /// types that implement [`Mul`] and [`Add`].
    vector_impl_dot_product,
    vector::impl_dot_product,
    vector::SimpleInput,
}


// ---------------------------------------------------------------------------------------------------------------------


export_macro! {
    /// Creates a matrix struct.
    ///
    /// See [this crate's documentation](self) for more details.
    create_matrix,
    matrix::create_base,
    matrix::CreationInput,
}


export_macro! {
    /// Implements operations between a matrix and its inner type.
    ///
    /// Implements the operations for all owned and reference types, commutatively wherever possible.
    ///
    /// Implements addition and subtraction through [`Add`] and [`Sub`] as well as [`AddAssign`] and [`SubAssign`]. As
    /// such, it can only be done for matrices that contain types that implement those traits.
    matrix_impl_scalar_ops,
    matrix::impl_scalar_ops,
    matrix::SimpleInput,
}

export_macro! {
    /// Implements component-wise operations between a matrix and itself.
    ///
    /// Implements the operations for all owned and reference types, commutatively wherever possible.
    ///
    /// Implements addition and subtraction through [`Add`] and [`Sub`] as well as [`AddAssign`] and [`SubAssign`]. As
    /// such, it can only be done for matrices that contain types that implement those traits.
    matrix_impl_self_ops,
    matrix::impl_self_ops,
    matrix::SimpleInput,
}
