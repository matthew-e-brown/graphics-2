//! Defines debugging-related types and implements debugging functionality on [`GLContext`].

use std::ffi::c_void;
use std::mem::align_of;
use std::ops::DerefMut;
use std::ptr;
use std::slice;

use crate::raw::types::*;
use crate::raw::{DONT_CARE as GL_DONT_CARE, MAX_DEBUG_MESSAGE_LENGTH as GL_MAX_DEBUG_MESSAGE_LENGTH};
use crate::{convert, gl_enum, GLContext};


gl_enum! {
    /// Sources of debug output messages.
    pub enum DebugSource {
        /// Calls to the OpenGL API.
        API => DEBUG_SOURCE_API,
        /// Calls to a window-system API.
        WindowSystem => DEBUG_SOURCE_WINDOW_SYSTEM,
        /// A compiler for a shading language.
        ShaderCompiler => DEBUG_SOURCE_SHADER_COMPILER,
        /// An application associated with OpenGL.
        ThirdParty => DEBUG_SOURCE_THIRD_PARTY,
        /// Generated by the user of this application.
        Application => DEBUG_SOURCE_APPLICATION,
        /// Some other source.
        Other => DEBUG_SOURCE_OTHER,
    }
}


gl_enum! {
    /// Types of debug output messages.
    pub enum DebugType {
        /// An error, typically from the API.
        Error => DEBUG_TYPE_ERROR,
        /// Some behavior marked deprecated has been used.
        DeprecatedBehavior => DEBUG_TYPE_DEPRECATED_BEHAVIOR,
        /// Something has invoked undefined behavior.
        UndefinedBehavior => DEBUG_TYPE_UNDEFINED_BEHAVIOR,
        /// Some functionality the user relies upon is not portable.
        Portability => DEBUG_TYPE_PORTABILITY,
        /// Code has triggered possible performance issues.
        Performance => DEBUG_TYPE_PERFORMANCE,
        /// Command stream annotation.
        Marker => DEBUG_TYPE_MARKER,
        /// [Group pushing](https://www.khronos.org/opengl/wiki/Debug_Output#Scoping_messages).
        PushGroup => DEBUG_TYPE_PUSH_GROUP,
        /// [Group popping](https://www.khronos.org/opengl/wiki/Debug_Output#Scoping_messages).
        PopGroup => DEBUG_TYPE_POP_GROUP,
        /// Some type that isn't one of these.
        Other => DEBUG_TYPE_OTHER,
    }
}


gl_enum! {
    /// Severity levels of debug output messages.
    pub enum DebugSeverity {
        /// Any GL error; dangerous undefined behavior; any shader compiler and linker errors.
        High => DEBUG_SEVERITY_HIGH,
        /// Severe performance warnings; GLSL or other shader compiler and linker warnings; use of currently deprecated behavior.
        Medium => DEBUG_SEVERITY_MEDIUM,
        /// Performance warnings from redundant state changes; trivial undefined behavior.
        Low => DEBUG_SEVERITY_LOW,
        /// Any message which is not an error or performance concern.
        Notification => DEBUG_SEVERITY_NOTIFICATION,
    }
}

impl DebugSeverity {
    /// Retrieves the appropriate [log level][log::Level] for this debug severity.
    ///
    /// Severities are mapped to log levels as follows:
    /// - High-severity messages are [`log::level::Error`];
    /// - Medium- and low-severity messages are [`log::level::Warn`];
    /// - Notification messages are [`log::level::Info`].
    pub fn log_level(self) -> log::Level {
        self.into()
    }
}

impl Into<log::Level> for DebugSeverity {
    fn into(self) -> log::Level {
        match self {
            DebugSeverity::High => log::Level::Error,
            DebugSeverity::Medium => log::Level::Warn,
            DebugSeverity::Low => log::Level::Warn,
            DebugSeverity::Notification => log::Level::Info,
        }
    }
}


/// All of the information that comprises a single debug output message.
///
/// This struct is analogous to the parameters that a `glDebugMessageCallback`'s `callback` parameter would usually
/// accept.
#[derive(Debug, Clone)]
pub struct DebugMessage {
    pub id: u32,
    pub typ: DebugType,
    pub source: DebugSource,
    pub severity: DebugSeverity,
    pub body: String,
}

impl DebugMessage {
    /// Returns a reference to this message's body text as a string slice.
    pub fn as_str(&self) -> &str {
        &self.body[..]
    }
}

impl AsRef<str> for DebugMessage {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}


/// Used to specify which debug messages are be configured by
/// [`debug_message_control`][GLContext::debug_message_control].
#[derive(Debug, Clone, Copy)]
pub enum DebugFilter<'a> {
    /// Enable or disable all messages whose source, type, and severity all match the provided values. A value of
    /// [`None`] corresponds to `GL_DONT_CARE`.
    Where {
        source: Option<DebugSource>,
        typ: Option<DebugType>,
        severity: Option<DebugSeverity>,
    },
    /// Enable or disable all messages whose source, type, *and* ID values exactly match those provided.
    ById {
        source: DebugSource,
        typ: DebugType,
        ids: &'a [GLuint],
    },
}


/// A helper function that copies a [`CStr`][std::ffi::CStr] message returned by OpenGL into an owned Rust [`String`].
/// Panics if any invariants are unmet.
unsafe fn msg_to_string(str: *const GLchar, len: GLsizei) -> String {
    // From OpenGL Spec 4.6 section 20.2:
    // > The memory for `message` is owned and managed by the GL, and should only be considered valid for the
    // > duration of the [callback].
    // Easiest thing to do is just to copy it into a plain Rust string.

    // Validate `str` and `len` before converting to slice
    let len: usize = len.try_into().expect("GL debug msg len must be 0 <= n <= isize::MAX");
    assert!(len <= (isize::MAX as usize), "GL debug msg len must be 0 <= n <= isize::MAX");
    assert!(!str.is_null(), "GL debug msg str must be non-null");
    assert!((str as usize).checked_add(len).is_some(), "GL debug msg str must not wrap address space");
    assert!(str.align_offset(align_of::<GLchar>()) == 0, "GL debug msg str must be aligned to GLchar");

    // SAFETY:
    // - Just validated length, wrapping, alignment, and non-null requirements
    // - We trust OpenGL to provide a string within a single allocated object
    // - OpenGL spec asserts that the message is valid for the duration of the callback (this function), long
    //   enough to read from
    // - We do not mutate the slice, only copy from it.
    let msg_slice: &[GLchar] = unsafe { slice::from_raw_parts(str, len) };

    // Hand-rolled "lossy" conversion into UTF-8 string
    msg_slice
        .into_iter()
        .map(|&c| {
            u32::try_from(c)
                .ok()
                .and_then(|u| char::from_u32(u))
                .unwrap_or(char::REPLACEMENT_CHARACTER)
        })
        .collect()
}


impl GLContext {
    /// Untested.
    pub fn debug_message_control(&self, filter: DebugFilter, enabled: bool) {
        let enabled = convert!(enabled, GLboolean, "'enabled' boolean");
        let (src, typ, sev, count, ids) = match filter {
            DebugFilter::Where { source: src, typ, severity: sev } => (
                src.map(|e| e.into_raw()).unwrap_or(GL_DONT_CARE),
                typ.map(|e| e.into_raw()).unwrap_or(GL_DONT_CARE),
                sev.map(|e| e.into_raw()).unwrap_or(GL_DONT_CARE),
                0,
                std::ptr::null(),
            ),
            DebugFilter::ById { source: src, typ, ids } => (
                src.into_raw(),
                typ.into_raw(),
                GL_DONT_CARE,
                convert!(ids.len(), GLsizei, "number of debug filter IDs"),
                ptr::from_ref(ids).cast(),
            ),
        };

        unsafe { self.gl.debug_message_control(src, typ, sev, count, ids, enabled) }
    }


    /// WIP/untested. Contains a lot of unsafe code, so it should be tested.
    pub fn get_debug_message_log(&self, count: usize) -> Vec<DebugMessage> {
        // Borrows pretty heavily from the example at: https://www.khronos.org/opengl/wiki/Debug_Output.

        // TODO: actually implement `glGet*`, with some nice enum stuff (or traits!!)
        let max_msg_len = {
            let mut n: GLint = 0;
            unsafe {
                self.gl.get_integer_v(GL_MAX_DEBUG_MESSAGE_LENGTH, ptr::from_mut(&mut n));
            }

            if n <= 0 {
                // should never happen, but w/e
                return vec![];
            } else {
                n as usize
            }
        };

        let mut text_data: Vec<GLchar> = Vec::with_capacity(count * max_msg_len);
        let mut src_data: Vec<GLenum> = Vec::with_capacity(count);
        let mut typ_data: Vec<GLenum> = Vec::with_capacity(count);
        let mut sev_data: Vec<GLenum> = Vec::with_capacity(count);
        let mut id_data: Vec<GLuint> = Vec::with_capacity(count);
        let mut lengths: Vec<GLsizei> = Vec::with_capacity(count);

        let count = convert!(count, GLuint, "number of debug message logs");
        let buf_size = convert!(text_data.capacity(), GLsizei, "total buffer size for debug message data");

        let num_found = unsafe {
            self.gl.get_debug_message_log(
                count,
                buf_size,
                src_data.as_mut_ptr(),
                typ_data.as_mut_ptr(),
                id_data.as_mut_ptr(),
                sev_data.as_mut_ptr(),
                lengths.as_mut_ptr(),
                text_data.as_mut_ptr(),
            )
        } as usize;

        // Once we know how many were put into the arrays behind the scenes, resize them to match.
        // SAFETY: OpenGL spec guarantees that it will not write more than `count` items into the given vectors.
        unsafe {
            src_data.set_len(num_found);
            typ_data.set_len(num_found);
            sev_data.set_len(num_found);
            id_data.set_len(num_found);
            lengths.set_len(num_found);
        };

        // Pointer into character data that we're going to inch along and copy out of.
        let mut str_ptr: *const GLchar = text_data.as_ptr();
        let mut messages = Vec::with_capacity(num_found);

        for msg in 0..num_found {
            let id = id_data[msg];
            let source = DebugSource::from_raw(src_data[msg]).expect("OpenGL should return a valid DebugSource");
            let severity = DebugSeverity::from_raw(sev_data[msg]).expect("OpenGL should return a valid DebugSeverity");
            let typ = DebugType::from_raw(typ_data[msg]).expect("OpenGL should return a valid DebugType");

            let str_len: GLsizei = lengths[msg];

            // SAFETY: The pointer comes from a Rust-allocated object, so it is known to be valid (does not overflow
            // isize, does not wrap, etc). `msg_to_string` does the rest of the required checks. First statement goes
            // for `byte_add` as well.
            let body = unsafe { msg_to_string(str_ptr, str_len) };
            str_ptr = unsafe { str_ptr.byte_add(str_len as usize) };

            messages.push(DebugMessage { id, typ, source, severity, body });
        }

        messages
    }


    /// This function requires a mutable reference to the context because the callback closure, if it captures anything,
    /// must be kept alive for as long as OpenGL may call the debug callback. If this function is called twice, the
    /// callback from the first call is replaced and its closure is dropped.
    ///
    /// Even though [`GLContext`] itself is neither [`Send`] nor [`Sync`], the provided closure must be `Sync`. This is
    /// because the OpenGL spec allows for a debug callback to be called from a different thread than the one that
    /// established the callback.
    ///
    /// [`glDebugMessageCallback`]: https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml
    pub fn debug_message_callback<F: FnMut(DebugMessage) + Sync + 'static>(&mut self, callback: F) {
        /// The function that actually receives OpenGL's callback.
        ///
        /// Instead of passing a pointer to the user's function, this implementation works by always setting this helper
        /// function as the debug callback. What we do instead is pass a pointer to the user's closure as our
        /// `user_param`, which OpenGL will pass back to us.
        ///
        /// A note on `extern "system"` from section 20.2, p.552/574 of the spec:
        ///
        /// > Additionally, _callback_ must be declared with the same platform-dependent calling convention used in the
        /// > definition of the type `DEBUGPROC`. Anything else will result in undefined behavior.
        ///
        /// This "platform-dependent calling convention" is given by the `GLAPIENTRY`/`APIENTRY` macros in OpenGL header
        /// files. On non-Windows platforms, these usually expand to nothing; on Windows, they usually expand to
        /// `__stdcall`. Hence the use of `extern "system"`: we simply use the system's calling convention.
        extern "system" fn intercept_debug_callback<C: FnMut(DebugMessage) + Sync + 'static>(
            src: GLenum,             // GLenum source
            typ: GLenum,             // GLenum type
            id: GLuint,              // GLuint id
            sev: GLenum,             // GLenum severity
            msg_len: GLsizei,        // GLsizei length
            msg_str: *const GLchar,  // const GLchar* message
            user_param: *mut c_void, // const void* userParam
        ) {
            // SAFETY: this function does all its own validation of the pointer and length, panicking if anything goes
            // wrong.
            let body = unsafe { msg_to_string(msg_str, msg_len) };

            // Check before we cast our pointer and call a method from it willy-nilly:
            assert!(!user_param.is_null(), "GL debug callback: pointer is null");
            assert!(user_param.align_offset(align_of::<C>()) == 0, "GL debug callback: pointer misaligned");

            // SAFETY:
            // - Alignment and non-null have been asserted.
            // - The memory (closure) living in the box will remain valid until the box is dropped; the box will not be
            //   dropped unless the struct is dropped; GLContext's drop impl calls `unset_debug_message_callback`, so by
            //   the time the closure is dropped this function will have been unset as the callback; so we never have to
            //   worry about calling a dropped closure.
            // - Since the `intercept_callback` function is private, the only time this function will ever be the
            //   callback is when we set it to be; since the only time we do that has the correct `userParam` value, we
            //   know it'll be the closure type we want.
            let closure = unsafe { (user_param as *mut C).as_mut().unwrap_unchecked() };

            closure(DebugMessage {
                id,
                typ: DebugType::from_raw(typ).unwrap_or(DebugType::Other),
                source: DebugSource::from_raw(src).unwrap_or(DebugSource::Other),
                severity: DebugSeverity::from_raw(sev).unwrap_or(DebugSeverity::High), // Default of High seems sensible
                body,
            });
        }

        // Get a pointer to the intercept function specifically instantiated with the right closure type
        let fn_ptr = intercept_debug_callback::<F>; // no ()

        let mut callback: Box<F> = Box::new(callback); // Move the closure to the heap so its address doesn't move
        let cb_ptr: *mut F = ptr::from_mut(Box::deref_mut(&mut callback)); // Get raw pointer to box's contents

        unsafe {
            self.gl.debug_message_callback(Some(fn_ptr), cb_ptr.cast());
        }

        // Store the pointer to our now-on-the-heap closure. As long as this struct stays alive, the box will be valid
        // and the closure will not be dropped. NB: we don't need to use `Pin` or anything like that since this is a
        // private field; nobody else can ever try and funny business (i.e. moving the closure out of the box).
        self.debug_callback = Some(callback);
    }


    /// Unsets the debug message callback which was previously established by [`Self::debug_message_callback`].
    ///
    /// If the previous callback was an owning closure, it will be dropped after this function is called.
    pub fn unset_debug_message_callback(&mut self) {
        unsafe {
            self.gl.debug_message_callback(None, std::ptr::null());
        }

        // Ensure we only perform the drop once we actually do the FFI call that takes the pointer away from OpenGL.
        // Otherwise, OpenGL may attempt to call into the function that no longer exists!
        self.debug_callback = None;
    }
}
