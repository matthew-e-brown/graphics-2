//! Defines debugging-related types and implements debugging functionality on [`GLContext`].
//! Types and implementations related to debug message output.

use std::borrow::Cow;
use std::ffi::c_void;
use std::mem::align_of;
use std::ops::DerefMut;
use std::{ptr, slice};

use crate::raw::types::*;
use crate::raw::{
    GLPointers,
    DONT_CARE as GL_DONT_CARE,
    MAX_DEBUG_MESSAGE_LENGTH as GL_MAX_DEBUG_MESSAGE_LENGTH,
    MAX_LABEL_LENGTH as GL_MAX_LABEL_LENGTH,
};
use crate::{convert, gl_enum, GLContext};


/// A box-wrapped debug message callback.
///
/// Even though [`GLContext`] itself is neither [`Send`] nor [`Sync`], closures provided to
/// [`debug_message_callback`][callback] must be `Sync`. This is because the OpenGL spec allows for a debug callback to
/// be called from a different thread than the one that established the callback.
///
/// [callback]: GLContext::debug_message_callback
pub type DebugClosure = Box<dyn FnMut(DebugMessage) + Sync + 'static>;


gl_enum! {
    /// Sources of debug output messages.
    pub enum DebugSource {
        /// Calls to the OpenGL API.
        API => DEBUG_SOURCE_API,
        /// Calls to a window-system API.
        WindowSystem => DEBUG_SOURCE_WINDOW_SYSTEM,
        /// A compiler for a shading language.
        ShaderCompiler => DEBUG_SOURCE_SHADER_COMPILER,
        /// An application associated with OpenGL.
        ThirdParty => DEBUG_SOURCE_THIRD_PARTY,
        /// Generated by the user of this application.
        Application => DEBUG_SOURCE_APPLICATION,
        /// Some other source.
        Other => DEBUG_SOURCE_OTHER,
    }
}

gl_enum! {
    /// Types of debug output messages.
    pub enum DebugType {
        /// An error, typically from the API.
        Error => DEBUG_TYPE_ERROR,
        /// Some behavior marked deprecated has been used.
        DeprecatedBehavior => DEBUG_TYPE_DEPRECATED_BEHAVIOR,
        /// Something has invoked undefined behavior.
        UndefinedBehavior => DEBUG_TYPE_UNDEFINED_BEHAVIOR,
        /// Some functionality the user relies upon is not portable.
        Portability => DEBUG_TYPE_PORTABILITY,
        /// Code has triggered possible performance issues.
        Performance => DEBUG_TYPE_PERFORMANCE,
        /// Command stream annotation.
        Marker => DEBUG_TYPE_MARKER,
        /// [Group pushing](https://www.khronos.org/opengl/wiki/Debug_Output#Scoping_messages).
        PushGroup => DEBUG_TYPE_PUSH_GROUP,
        /// [Group popping](https://www.khronos.org/opengl/wiki/Debug_Output#Scoping_messages).
        PopGroup => DEBUG_TYPE_POP_GROUP,
        /// Some other type of message.
        Other => DEBUG_TYPE_OTHER,
    }
}

gl_enum! {
    /// Severity levels of debug output messages.
    pub enum DebugSeverity {
        /// A high-severity message: any GL error; dangerous undefined behavior; any shader compiler and linker errors.
        High => DEBUG_SEVERITY_HIGH,
        /// A medium-severity message: severe performance warnings; GLSL or other shader compiler and linker warnings;
        /// use of currently deprecated behavior.
        Medium => DEBUG_SEVERITY_MEDIUM,
        /// A low-severity message: performance warnings from redundant state changes; trivial undefined behavior.
        Low => DEBUG_SEVERITY_LOW,
        /// A notification: any message which is not an error or performance concern.
        Notification => DEBUG_SEVERITY_NOTIFICATION,
    }
}

impl DebugSeverity {
    /// Retrieves the appropriate [log level][log::Level] for this debug severity.
    ///
    /// Severities are mapped to log levels as follows:
    /// - High-severity messages are [`log::level::Error`];
    /// - Medium- and low-severity messages are [`log::level::Warn`];
    /// - Notification messages are [`log::level::Info`].
    pub fn log_level(self) -> log::Level {
        self.into()
    }
}

impl Into<log::Level> for DebugSeverity {
    fn into(self) -> log::Level {
        match self {
            DebugSeverity::High => log::Level::Error,
            DebugSeverity::Medium => log::Level::Warn,
            DebugSeverity::Low => log::Level::Warn,
            DebugSeverity::Notification => log::Level::Info,
        }
    }
}


// Same as the structs above, but with `GL_DONT_CARE` added to them.

gl_enum! {
    /// Filters for sources of debug output messages, for use with [`GLContext::debug_message_control`].
    ///
    /// See also [`DebugSource`].
    pub enum DebugSourceFilter {
        /// Filter for debug messages caused by any source.
        DontCare => DONT_CARE,
        /// Filter for debug messages caused by calls to the OpenGL API.
        API => DEBUG_SOURCE_API,
        /// Filter for debug messages caused by calls to a window-system API.
        WindowSystem => DEBUG_SOURCE_WINDOW_SYSTEM,
        /// Filter for debug messages caused by a compiler for a shading language.
        ShaderCompiler => DEBUG_SOURCE_SHADER_COMPILER,
        /// Filter for debug messages caused by an application associated with OpenGL.
        ThirdParty => DEBUG_SOURCE_THIRD_PARTY,
        /// Filter for debug messages caused by generated by the user of this application.
        Application => DEBUG_SOURCE_APPLICATION,
        /// Filter for debug messages caused by some other source.
        Other => DEBUG_SOURCE_OTHER,
    }
}

gl_enum! {
    /// Filters for types of debug output messages, for use with [`GLContext::debug_message_control`].
    ///
    /// See also [`DebugType`].
    pub enum DebugTypeFilter {
        /// Filter for debug messages of any type.
        DontCare => DONT_CARE,
        /// Filter for debug messages about errors, typically those raised from the API.
        Error => DEBUG_TYPE_ERROR,
        /// Filter for debug messages caused by the use of some deprecated behavior.
        DeprecatedBehavior => DEBUG_TYPE_DEPRECATED_BEHAVIOR,
        /// Filter for debug messages caused by invoking undefined behavior of some sort.
        UndefinedBehavior => DEBUG_TYPE_UNDEFINED_BEHAVIOR,
        /// Filter for debug messages related to the use of some non-portable functionality.
        Portability => DEBUG_TYPE_PORTABILITY,
        /// Filter for debug messages relating to possible performance issues.
        Performance => DEBUG_TYPE_PERFORMANCE,
        /// Filter for markers/stream annotations.
        Marker => DEBUG_TYPE_MARKER,
        /// Filter for debug messages related to [group
        /// pushing](https://www.khronos.org/opengl/wiki/Debug_Output#Scoping_messages).
        PushGroup => DEBUG_TYPE_PUSH_GROUP,
        /// Filter for debug messages related to [group
        /// popping](https://www.khronos.org/opengl/wiki/Debug_Output#Scoping_messages).
        PopGroup => DEBUG_TYPE_POP_GROUP,
        /// Filter for debug messages related of all other types.
        Other => DEBUG_TYPE_OTHER,
    }
}

gl_enum! {
    /// Filters for severities of debug output messages, for use with [`GLContext::debug_message_control`].
    ///
    /// See also [`DebugSeverity`].
    pub enum DebugSeverityFilter {
        /// Filter for debug messages of any severity.
        DontCare => DONT_CARE,
        /// Filter for high-severity messages: any GL error; dangerous undefined behavior; any shader compiler and
        /// linker errors.
        High => DEBUG_SEVERITY_HIGH,
        /// Filter for medium-severity messages: severe performance warnings; GLSL or other shader compiler and linker
        /// warnings; use of currently deprecated behavior.
        Medium => DEBUG_SEVERITY_MEDIUM,
        /// Filter for low-severity messages: performance warnings from redundant state changes; trivial undefined
        /// behavior.
        Low => DEBUG_SEVERITY_LOW,
        /// Filter for notifications: any message which is not an error or performance concern.
        Notification => DEBUG_SEVERITY_NOTIFICATION,
    }
}


/// All of the information that comprises a single debug output message.
///
/// This struct is analogous to the parameters that a `glDebugMessageCallback`'s `callback` parameter would usually
/// accept.
#[derive(Debug, Clone)]
pub struct DebugMessage {
    pub id: u32, // `u32` instead of `GLuint` since this struct is for use after/before the Rust--GL conversion happens
    pub typ: DebugType,
    pub source: DebugSource,
    pub severity: DebugSeverity,
    pub body: String,
}

impl DebugMessage {
    /// Returns a reference to this message's body text as a string slice.
    pub fn as_str(&self) -> &str {
        &self.body[..]
    }
}

impl AsRef<str> for DebugMessage {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}


gl_enum! {
    /// The possible sources of custom-inserted debug messages and debug groups.
    pub enum DebugInsertSource {
        /// [`DebugMessageSource::Application`].
        Application => DEBUG_SOURCE_APPLICATION,
        /// [`DebugMessageSource::ThirdParty`].
        ThirdParty => DEBUG_SOURCE_THIRD_PARTY,
    }
}

impl From<DebugInsertSource> for DebugSource {
    fn from(value: DebugInsertSource) -> Self {
        match value {
            DebugInsertSource::Application => DebugSource::Application,
            DebugInsertSource::ThirdParty => DebugSource::ThirdParty,
        }
    }
}

/// An "insertable" version of [`DebugMessage`].
///
/// Note that this struct is only used [when inserting][insert] custom debug messages; once they come out the other
/// side, they'll be regular [`DebugMessage`]s again.
///
/// [insert]: GLContext::debug_message_insert
#[derive(Debug, Clone)]
pub struct DebugInsertMessage<'a> {
    pub id: GLuint,
    pub typ: DebugType,
    pub source: DebugInsertSource,
    pub severity: DebugSeverity,
    pub body: Cow<'a, str>,
}

impl DebugInsertMessage<'_> {
    /// Returns a reference to this message's body as a string slice.
    pub fn as_str(&self) -> &str {
        &self.body[..]
    }

    /// Converts this insertable debug message into a normal one.
    pub fn into_message(self) -> DebugMessage {
        DebugMessage {
            id: self.id,
            typ: self.typ,
            source: self.source.into(),
            severity: self.severity,
            body: self.body.into_owned(),
        }
    }
}

impl AsRef<str> for DebugInsertMessage<'_> {
    fn as_ref(&self) -> &str {
        self.as_str()
    }
}


/// Used to reference, enable, and disable a subset of messages when configuring debug output messages with
/// [`debug_message_control`][GLContext::debug_message_control]. See that method's documentation for more.
#[derive(Debug, Clone, Copy)]
pub enum DebugFilter<'a> {
    /// Enable or disable all messages whose source, type, **or** severity match the provided values.
    Where {
        source: DebugSourceFilter,
        typ: DebugTypeFilter,
        severity: DebugSeverityFilter,
    },
    /// Enable or disable all messages whose source, type, **and** ID values exactly match those provided.
    ById {
        /// When filtering by IDs, `source` must not be `GL_DONT_CARE`.
        source: DebugSource,
        /// When filtering by IDs, `type` must not be `GL_DONT_CARE`.
        typ: DebugType,
        ids: &'a [GLuint],
    },
}


/// The ID (technically the "name") and type of an OpenGL object one wishes to apply a [debug label] to. In the case of
/// a [sync object][ObjectID::SyncObject], the object's handle is given instead (which is an opaque/`void` pointer under
/// the hood).
///
/// [FIXME] Once all of these object types have been implemented, these variants should contain `&mut` references to
/// each of them, since they technically modify the internal state of the respective object. That means we'll probably
/// also need a separate version for `glGetObjectLabel`, since that one shouldn't need mutable access.
///
/// [debug label]: GLContext::object_label
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ObjectID {
    Buffer(GLuint),
    Framebuffer(GLuint),
    ProgramPipeline(GLuint),
    Program(GLuint),
    Query(GLuint),
    Renderbuffer(GLuint),
    Sampler(GLuint),
    Shader(GLuint),
    Texture(GLuint),
    TransformFeedback(GLuint),
    VertexArray(GLuint),
    /// Labelling this object type will result in a call to `glObjectPtrLabel` instead of `glObjectLabel`.
    SyncObject(GLsync),
}

impl ObjectID {
    /// Helper function to "unwrap" this ObjectID into the actual ID and type enum. Panics if this is a `SyncObject`
    /// variant, since it does not have a `GLuint` as its ID.
    #[inline(always)] // to hopefully optimize away the `panic` branch when already inside an else-if
    fn into_raw_parts(self) -> (GLuint, GLenum) {
        use crate::raw;
        match self {
            Self::Buffer(id) => (id, raw::BUFFER),
            Self::Framebuffer(id) => (id, raw::FRAMEBUFFER),
            Self::ProgramPipeline(id) => (id, raw::PROGRAM_PIPELINE),
            Self::Program(id) => (id, raw::PROGRAM),
            Self::Query(id) => (id, raw::QUERY),
            Self::Renderbuffer(id) => (id, raw::RENDERBUFFER),
            Self::Sampler(id) => (id, raw::SAMPLER),
            Self::Shader(id) => (id, raw::SHADER),
            Self::Texture(id) => (id, raw::TEXTURE),
            Self::TransformFeedback(id) => (id, raw::TRANSFORM_FEEDBACK),
            Self::VertexArray(id) => (id, raw::VERTEX_ARRAY),
            Self::SyncObject(_) => panic!("cannot unwrap ObjectID::SyncObject(GLsync) into (GLuint, GLenum)"),
        }
    }
}


/// A helper function that copies a [`CStr`][std::ffi::CStr] message returned by OpenGL into an owned Rust [`String`].
///
/// This function can be used for both NUL-terminated and length-based strings. At most `len` bytes of the string are
/// copied, up to the first NUL-terminator. Any characters that are not valid UTF-8 are replaced with
/// [`char::REPLACEMENT_CHARACTER`].
///
/// # Safety
///
/// The only invariant the caller must uphold is that `str` actually points to a valid `GLchar` buffer. This function is
/// fairly safe because it will simply panic if any invariants are not met.
///
/// # Panics
///
/// This function panics if any of the following are **not** true:
///
/// - 0 ≤ `len` ≤ `isize::MAX`.
/// - `str` is not null.
/// - `str + len` does not wrap around the address space (`str + len` ≤ `usize::MAX`).
/// - `str` is aligned with `GLchar` (trivial; chars should always just be 1-aligned).
unsafe fn msg_to_string(str: *const GLchar, len: usize) -> String {
    // From OpenGL Spec 4.6 section 20.2:
    //
    // > The memory for `message` is owned and managed by the GL, and should only be considered valid for the
    // > duration of the [callback].
    //
    // Easiest thing to do here is to just copy it into a plain Rust string and let OpenGL keep its CStr.

    // Validate `str` and `len` before converting to slice
    let len = convert!(len, usize, msg: "GL debug msg len must be 0 <= n <= isize::MAX");
    assert!(len <= (isize::MAX as usize), "GL debug msg len must be 0 <= n <= isize::MAX");
    assert!(!str.is_null(), "GL debug msg str must be non-null");
    assert!((str as usize).checked_add(len).is_some(), "GL debug msg str must not wrap address space");
    assert!(str.align_offset(align_of::<GLchar>()) == 0, "GL debug msg str must be aligned to GLchar");

    // Reinterpret potentially-signed char as raw bytes (it's a string, negative character isn't valid anyways)
    let str = str.cast::<u8>();

    // SAFETY:
    // - Just validated length, wrapping, alignment, and non-null requirements
    // - We trust OpenGL to provide a string within a single allocated object
    // - OpenGL spec asserts that the message is valid for the duration of the callback (this function), long
    //   enough to read from
    // - We do not mutate the slice, only copy from it.
    let mut msg_slice: &[u8] = unsafe { slice::from_raw_parts(str, len) };

    // Truncate the buffer so that it stops at the first NUL, just in case `len` is a bit overzealous.
    if let Some(null_pos) = msg_slice.iter().position(|c| *c == 0) {
        msg_slice = &msg_slice[..null_pos];
    }

    String::from_utf8_lossy(msg_slice).into_owned()
}

// [FIXME] Change these to use the high-level `glGet*` commands once they're implemented

#[inline]
fn get_max_message_len(gl: &GLPointers) -> usize {
    let mut n: GLint = 0;
    unsafe {
        gl.get_integer_v(GL_MAX_DEBUG_MESSAGE_LENGTH, &mut n);
    }

    usize::try_from(n).expect("OpenGL MAX_DEBUG_MESSAGE_LENGTH should be >= 0")
}

#[inline]
fn get_max_label_len(gl: &GLPointers) -> usize {
    let mut n: GLint = 0;
    unsafe {
        gl.get_integer_v(GL_MAX_LABEL_LENGTH, &mut n);
    }

    usize::try_from(n).expect("OpenGL MAX_LABEL_LENGTH should be >= 0")
}

// [TODO] Since basically all of these messages need to mutate the debugging state, it'd maybe a good idea to separate
// these messages into a separate struct, like a `DebugContext`. That way, the original `GLContext` can remain
// un-`&mut`'ed, and anything that wishes to do debugging can be given a `RefCell<DebugContext>` or something. That'll
// become especially more important as we implement features like custom message insertion and grouping.

impl GLContext {
    /// Controls the volume of debug message output by disabling or enabling a subset of messages.
    ///
    /// Any messaging controls configured with this method are local to the current [debug group]. Popping a debug group
    /// restores the previous group's message settings.
    ///
    /// This method attempts to match the interface of [`glDebugMessageControl`] as closely as possible. See section
    /// 20.4 in the spec (4.6 Core profile, May 2022) for the original documentation.
    ///
    /// [`glDebugMessageControl`] has two modes of operation:
    ///
    /// - A filter based on `source`, `type`, and `severity`; implemented here with [`DebugFilter::Where`], and
    ///   implemented in the underlying command by passing an empty `ids` array with a `count` of zero.
    ///   - All messages whose `source`, `type`, **or** `severity` match the provided values are referenced.
    ///   - If any of these is `GL_DONT_CARE`, then messages from all sources, of all types, or of all severities are
    ///     referenced. Setting all three to `GL_DONT_CARE` will reference all debug messages.
    /// - A more precise filter wherein a list of message IDs to reference are provided, along with message source and
    ///   type.
    ///   - `severity` must be `GL_DONT_CARE` for this mode.
    ///   - Unrecognized IDs are ignored.
    ///
    /// Note that debug output is disabled entirely by default, unless either (a) it was enabled with
    /// [`GLContext::enable`] and [`EnableCap::DebugOutput`][crate::EnableCap::DebugOutput]; or (b) the context was
    /// originally created with the `CONTEXT_FLAG_DEBUG_BIT` set.
    ///
    /// [`glDebugMessageControl`]: https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageControl.xhtml
    /// [debug group]: Self::push_debug_group
    pub fn debug_message_control(&mut self, filter: DebugFilter, enabled: bool) {
        let enabled = convert!(enabled, GLboolean, "'enabled' boolean");
        let (src, typ, sev, count, ids) = match filter {
            DebugFilter::Where { source: src, typ, severity: sev } => (
                src.into_raw(),
                typ.into_raw(),
                sev.into_raw(),
                0,           // count of 0
                ptr::null(), // no array of IDs
            ),
            DebugFilter::ById { source: src, typ, ids } => (
                src.into_raw(),
                typ.into_raw(),
                GL_DONT_CARE, // severity must always be GL_DONT_CARE when doing ID-based filtering
                convert!(ids.len(), GLsizei, "number of debug filter IDs"),
                ptr::from_ref(ids).cast::<GLuint>(),
            ),
        };

        unsafe { self.gl.debug_message_control(src, typ, sev, count, ids, enabled) }
    }

    /// Retrieves at most `count` messages from the debug message log. Messages that are fetched will be removed from
    /// the log (hence the `&mut`).
    ///
    /// [WARN] **This method has not been tested yet!**
    ///
    /// Messages are fetched from oldest to newest.
    ///
    /// If the context is not a debug context, this method will always return zero messages. Messages are only stored in
    /// the log if a [a custom debug callback function][Self::debug_message_callback] is not set. That is, if one is
    /// set, this method will always return an empty list.
    ///
    /// [TODO] when we implement `DebugContext` struct, add a general note about enabling debugging to that struct
    /// instead of having it in each function doc.
    ///
    pub fn get_debug_message_log(&mut self, count: usize) -> Vec<DebugMessage> {
        // This implementation borrows pretty heavily from the example on the OpenGL Wiki:
        // https://www.khronos.org/opengl/wiki/Debug_Output.

        // Allocate string data as zeroes just so that any space after the last message is NUL terminated instead of
        // arbitrary junk. `max_msg_len` is guaranteed by the spec to include null terminators.
        let max_msg_len = get_max_message_len(&self.gl);
        let mut str_data: Vec<GLchar> = vec![0; count * max_msg_len];

        if str_data.len() == 0 {
            return vec![];
        }

        // The rest can be left non-zeroed, since the spec guarantees it'll write `count` valid `GLenum` values into
        // them.
        let mut src_data: Vec<GLenum> = Vec::with_capacity(count);
        let mut typ_data: Vec<GLenum> = Vec::with_capacity(count);
        let mut sev_data: Vec<GLenum> = Vec::with_capacity(count);
        let mut id_data: Vec<GLuint> = Vec::with_capacity(count);
        let mut lengths: Vec<GLsizei> = Vec::with_capacity(count);

        // Perform the actual query
        let num_found = unsafe {
            self.gl.get_debug_message_log(
                convert!(count, GLuint, "number of debug message logs"),
                convert!(str_data.len(), GLsizei, "total buffer size for 'count' debug messages in log"),
                src_data.as_mut_ptr(),
                typ_data.as_mut_ptr(),
                id_data.as_mut_ptr(),
                sev_data.as_mut_ptr(),
                lengths.as_mut_ptr(),
                str_data.as_mut_ptr(),
            )
        } as usize;

        assert!(num_found <= count, "glGetDebugMessageLog returned more than count items");

        // Once we know how many things OpenGL put into them, resize vector lengths to match.
        // SAFETY: OpenGL spec guarantees that it will not write more than `count` items into the given vectors.
        unsafe {
            src_data.set_len(num_found);
            typ_data.set_len(num_found);
            sev_data.set_len(num_found);
            id_data.set_len(num_found);
            lengths.set_len(num_found);
        };

        // Just in case...
        *str_data.last_mut().unwrap() = 0; // unwrap is fine since we alloc'd this buffer w/ a length > 0

        // Convert buffer pointer range into an inclusive one so it's more intuitive when using `range.contains`
        let buff_range = {
            let range = str_data.as_ptr_range();
            let s = range.start;
            let e = unsafe { range.end.byte_sub(1) }; // SAFETY: `range.end` just came from a buffer with length >= 1.
            s..=e
        };

        let mut messages: Vec<DebugMessage> = Vec::with_capacity(num_found);
        let mut str_ptr = *buff_range.start();

        for i in 0..num_found {
            let id = id_data[i];

            let typ = DebugType::from_raw(typ_data[i]).expect("OpenGL should return a valid DebugType");
            let source = DebugSource::from_raw(src_data[i]).expect("OpenGL should return a valid DebugSource");
            let severity = DebugSeverity::from_raw(sev_data[i]).expect("OpenGL should return a valid DebugSeverity");

            // SAFETY: see comments within the block. In general, pointers used are obtained through an iterative
            let body = unsafe {
                // Make sure not to go off the end of the buffer after incrementing str_ptr last iteration
                assert!(buff_range.contains(&str_ptr), "OpenGL message string overflowed buffer");

                // Compute number of bytes left in buffer to clamp the length we end up reading.
                // Offset from start will always be positive since we've just been adding each time.
                let buf_remaining = str_data.len() - str_ptr.byte_offset_from(*buff_range.start()) as usize;

                // Need to do some whimsical casting shenanigans: i32 to usize so we can clamp our usize (just in case
                // more than i32::MAX remain), but also convert the clamped usize back to i32. Then use that to clamp
                // another i32, which we want as a usize since it's a length. lol.
                let len_max = buf_remaining.min(GLsizei::MAX as usize) as GLsizei;
                let msg_len = lengths[i].clamp(0, len_max) as usize;

                // We know str_ptr points to a valid string buffer cuz of our assertions, this function does the rest.
                // Note that it will stop before msg_len if there's a null byte in the buffer.
                let body = msg_to_string(str_ptr, msg_len);

                // Increment our pointer forwards (by the full length, even if msg_to_string stopped early).
                str_ptr = str_ptr.byte_add(msg_len);

                // One last check: if there's more buffer left over, gobble up any NUL bytes between this string and the
                // next. Spec says there should always be exactly one, but you can't trust anybody these days. Pointer
                // is safe to dereference as `GLchar` since the loop checks it is within the bounds of the buffer.
                while buff_range.contains(&str_ptr) {
                    if *str_ptr == 0 {
                        str_ptr = str_ptr.byte_add(1);
                    } else {
                        break;
                    }
                }

                body
            };

            messages.push(DebugMessage { id, typ, source, severity, body });
        }

        messages
    }

    /// Sets the given function as the OpenGL debug message callback.
    ///
    /// If this function is called twice, the callback from the first call is replaced and its closure is dropped.
    ///
    /// Even though [`GLContext`] itself is neither [`Send`] nor [`Sync`], the provided closure must be `Sync`. This is
    /// because the OpenGL spec allows for a debug callback to be called from a different thread than the one that
    /// established the callback. This possibility can be disabled with with [`EnableCap::DebugOutputSynchronous`],
    /// which would theoretically allow for a non-`Sync` closure here, but there's no way to know if that capability is
    /// enabled or disabled in the type system.
    ///
    /// Note that debug outputs must be enabled with [`GLContext::enable`].
    ///
    /// [`glDebugMessageCallback`]: https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml
    pub fn debug_message_callback<F: FnMut(DebugMessage) + Sync + 'static>(&mut self, callback: F) {
        /// The function that actually receives OpenGL's callback.
        ///
        /// Instead of passing a pointer to the user's function, this implementation works by always setting this helper
        /// function as the debug callback. What we do instead is pass a pointer to the user's closure as our
        /// `user_param`, which OpenGL will pass back to us.
        ///
        /// A note on `extern "system"` from section 20.2, p.552/574 of the spec:
        ///
        /// > Additionally, _callback_ must be declared with the same platform-dependent calling convention used in the
        /// > definition of the type `DEBUGPROC`. Anything else will result in undefined behavior.
        ///
        /// This "platform-dependent calling convention" is given by the `GLAPIENTRY`/`APIENTRY` macros in OpenGL header
        /// files. On non-Windows platforms, these usually expand to nothing; on Windows, they usually expand to
        /// `__stdcall`. Hence the use of `extern "system"`: we simply use the system's calling convention.
        extern "system" fn intercept_debug_callback<C: FnMut(DebugMessage) + Sync + 'static>(
            src: GLenum,             // GLenum source
            typ: GLenum,             // GLenum type
            id: GLuint,              // GLuint id
            sev: GLenum,             // GLenum severity
            msg_len: GLsizei,        // GLsizei length
            msg_str: *const GLchar,  // const GLchar* message
            user_param: *mut c_void, // const void* userParam
        ) {
            // SAFETY: the only thing we need to guarantee is that `msg_str` is a valid pointer; there's not much we can
            // do here aside from trust OpenGL, but I think that's a reasonable assumption to make.
            let msg_len = msg_len.max(0) as usize; // clamp at zero
            let body = unsafe { msg_to_string(msg_str, msg_len) };

            assert!(!user_param.is_null(), "GL debug callback: pointer is null");
            assert!(user_param.align_offset(align_of::<C>()) == 0, "GL debug callback: pointer misaligned");

            // SAFETY:
            // - Alignment and non-null have been asserted.
            // - The memory (closure) living in the box will remain valid until the box is dropped; the box will not be
            //   dropped unless the struct is dropped; GLContext's drop impl calls `unset_debug_message_callback`, so by
            //   the time the closure is dropped this function will have been unset as the callback; so we never have to
            //   worry about calling a dropped closure.
            // - Since the `intercept_callback` function is private, the only time this function will ever be the
            //   callback is when we set it to be; since the only time we do that has the correct `userParam` value, we
            //   know it'll be the closure type we want.
            let closure = unsafe { (user_param as *mut C).as_mut().unwrap_unchecked() };

            closure(DebugMessage {
                id,
                typ: DebugType::from_raw(typ).unwrap_or(DebugType::Other),
                source: DebugSource::from_raw(src).unwrap_or(DebugSource::Other),
                severity: DebugSeverity::from_raw(sev).unwrap_or(DebugSeverity::High), // Default of High seems sensible
                body,
            });
        }

        // Get a pointer to the intercept function specifically instantiated with the right closure type
        let fn_ptr = intercept_debug_callback::<F>; // no ()

        let mut callback: Box<F> = Box::new(callback); // Move the closure to the heap so its address doesn't move
        let cb_ptr: *mut F = ptr::from_mut(Box::deref_mut(&mut callback)); // Get raw pointer to box's contents

        unsafe {
            self.gl.debug_message_callback(Some(fn_ptr), cb_ptr.cast::<c_void>());
        }

        // Store the pointer to our now-on-the-heap closure. As long as this struct stays alive, the box will be valid
        // and the closure will not be dropped. NB: we don't need to use `Pin` or anything like that since this is a
        // private field; nobody else can ever try and funny business (i.e. moving the closure out of the box).
        self.debug_callback.set(Some(callback));
    }

    /// Unsets the debug message callback which was previously established by [`Self::debug_message_callback`].
    ///
    /// If the previous callback was an owning closure, it will be dropped after this function is called.
    pub fn unset_debug_message_callback(&mut self) {
        let callback = self.debug_callback.take();
        if callback.is_some() {
            unsafe {
                self.gl.debug_message_callback(None, ptr::null());
            }
        }
    }

    /// Generates a user-defined debug message in the context's debug message log.
    ///
    /// Note that this function does nothing is debug output is disabled (see [`EnableCap::DebugOutput`]).
    ///
    /// [`EnableCap::DebugOutput`]: crate::EnableCap::DebugOutput
    pub fn debug_message_insert(&mut self, message: &DebugInsertMessage<'_>) {
        let len = convert!(message.body.len(), GLsizei, "debug message body length");
        let buf = message.body.as_ptr().cast::<GLchar>();
        unsafe {
            self.gl.debug_message_insert(
                message.source.into_raw(),
                message.typ.into_raw(),
                message.id,
                message.severity.into_raw(),
                len,
                buf,
            )
        }
    }

    /// Pushes a debug group onto the stack of debugging groups.
    ///
    /// This action will trigger a [notification-level][DebugSeverity::Notification] debug message signaling the start
    /// of the new group. Any changes to [debug message volume controls][Self::debug_message_control] while this group
    /// is at the top of the stack are local to this group; [popping][Self::pop_debug_group] this group will restore the
    /// previous message control settings.
    pub fn push_debug_group(&mut self, source: DebugInsertSource, id: u32, name: &str) {
        let len = convert!(name.len(), GLsizei, "debug group name length");
        let buf = name.as_ptr().cast::<GLchar>();
        unsafe { self.gl.push_debug_group(source.into_raw(), id, len, buf) }
    }

    /// Pops the top debug group off of the debugging group stack.
    ///
    /// This action will trigger a [notification-level][DebugSeverity::Notification] debug message signaling the start
    /// of the new group; a `STACK_UNDERFLOW` error will be generated if the stack is currently empty. This will restore
    /// the [message control status][Self::debug_message_control] of the previous group.
    pub fn pop_debug_group(&mut self) {
        unsafe { self.gl.pop_debug_group() }
    }

    /// Labels an OpenGL object for the purposes of debugging output.
    ///
    /// This command will generate an error if the ID given in `object` is not the ID ("name") an OpenGL object, or if
    /// it is the ID of the wrong type of object.
    ///
    /// Object labels are part of an object's state.
    pub fn object_label(&mut self, object: ObjectID, label: &str) {
        let len = convert!(label.len(), GLsizei, "object debug label length");
        let buf = label.as_ptr().cast::<GLchar>();

        if let ObjectID::SyncObject(handle) = object {
            unsafe { self.gl.object_ptr_label(handle.cast::<c_void>(), len, buf) }
        } else {
            let (name, ty) = object.into_raw_parts();
            unsafe { self.gl.object_label(ty, name, len, buf) }
        }
    }

    pub fn get_object_label(&self, object: ObjectID) -> String {
        let max_lbl_len = get_max_label_len(&self.gl);

        let mut length: GLsizei = 0;
        let mut buffer: Vec<GLchar> = vec![0; max_lbl_len]; // filled NUL just in case

        let buf_size = convert!(buffer.len(), GLsizei, "OpenGL max label size");

        if let ObjectID::SyncObject(handle) = object {
            let handle = handle.cast::<c_void>();
            unsafe { self.gl.get_object_ptr_label(handle, buf_size, &mut length, buffer.as_mut_ptr()) }
        } else {
            let (name, ty) = object.into_raw_parts();
            unsafe { self.gl.get_object_label(ty, name, buf_size, &mut length, buffer.as_mut_ptr()) }
        }

        let length = length.max(0) as usize; // clamp to zero just in case

        // SAFETY: `buffer` is a valid pointer, since we allocate it ourselves.
        unsafe { msg_to_string(buffer.as_ptr(), length) }
    }
}
